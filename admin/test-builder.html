<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Construtor de Testes | Anova Saúde</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚙️</text></svg>">
  <link rel="stylesheet" href="/css/style.css">
  <style>
    * { box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body { background: #faf8f5; margin: 0; padding: 1rem; font-family: 'Work Sans', sans-serif; }
    
    /* Custom scrollbar for better visibility */
    ::-webkit-scrollbar { width: 12px; }
    ::-webkit-scrollbar-track { background: #e8e8e8; border-radius: 10px; }
    ::-webkit-scrollbar-thumb { background: #1a4d2e; border-radius: 10px; border: 2px solid #e8e8e8; }
    ::-webkit-scrollbar-thumb:hover { background: #2d6a4f; }
    * { scrollbar-width: thin; scrollbar-color: #1a4d2e #e8e8e8; }
    
    .container { max-width: 1600px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.06); overflow: hidden; }
    
    .header { background: #1a4d2e; color: white; padding: 2rem; }
    .header h1 { margin: 0 0 0.5rem; font-size: 1.75rem; font-weight: 600; }
    .header p { margin: 0; opacity: 0.9; font-size: 1rem; }
    
    .toolbar { padding: 1.25rem; border-bottom: 1px solid #e0e0e0; background: #f8f9fa; }
    .toolbar-row { display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }
    .toolbar-row:not(:last-child) { margin-bottom: 0.75rem; }
    .toolbar-row.center { justify-content: center; }
    .toolbar-separator { color: #6c757d; font-weight: 300; font-size: 1.2rem; margin: 0 0.5rem; }
    .toolbar-label { color: #5a5a5a; font-size: 0.9rem; font-weight: 500; margin-right: 0.5rem; }
    .status { margin-left: auto; color: #5a5a5a; font-size: 0.9rem; font-weight: 500; }
    
    .btn { padding: 0.6rem 1.1rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 600; transition: all 0.2s; min-width: 110px; }
    .btn-primary { background: #1a4d2e; color: white; }
    .btn-primary:hover { background: #2d6a4f; transform: translateY(-1px); }
    .btn-success { background: #28a745; color: white; }
    .btn-success:hover { background: #218838; transform: translateY(-1px); }
    .btn-secondary { background: #6c757d; color: white; }
    .btn-secondary:hover { background: #5a6268; }
    .btn-danger { background: #dc3545; color: white; font-size: 0.85rem; }
    .btn-danger:hover { background: #c82333; }
    .btn-small { padding: 0.4rem 0.8rem; font-size: 0.85rem; }
    
    .content { padding: 2rem; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2.5rem; }
    
    .field { margin-bottom: 1.25rem; }
    .field label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #2b2b2b; font-size: 0.95rem; }
    .field input, .field textarea, .field select { width: 100%; padding: 0.75rem; border: 1px solid #d0d0d0; border-radius: 6px; font-size: 0.95rem; font-family: inherit; transition: border-color 0.2s; background: white; }
    .field input:focus, .field textarea:focus, .field select:focus { outline: none; border-color: #1a4d2e; }
    .field textarea { min-height: 110px; resize: vertical; }
    .field textarea.tall { min-height: 150px; }
    .field small { display: block; margin-top: 0.3rem; color: #6c757d; font-size: 0.85rem; }
    
    .formatting-toolbar { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
    .btn-format { padding: 0.4rem 0.7rem; background: #f0f0f0; border: 1px solid #d0d0d0; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s; }
    .btn-format:hover { background: #e0e0e0; border-color: #b0b0b0; }
    .btn-format:active { background: #d0d0d0; }
    
    .checkbox-group { display: flex; gap: 1rem; margin-top: 0.5rem; }
    .checkbox-label { display: inline-flex; align-items: center; gap: 0.6rem; padding: 0.6rem 1rem; border: 2px solid #e0e0e0; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s; background: white; }
    .checkbox-label:hover { border-color: #1a4d2e; background: #f8f9fa; }
    .checkbox-label input:checked { accent-color: #1a4d2e; }
    
    .section { margin-bottom: 3rem; }
    .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 0.75rem; border-bottom: 2px solid #d0d0d0; }
    .section-header h3 { margin: 0; color: #2b2b2b; font-size: 1.2rem; display: flex; align-items: center; gap: 0.75rem; font-weight: 600; }
    .section-header-left { display: flex; align-items: center; gap: 1rem; }
    .badge { display: inline-flex; align-items: center; justify-content: center; min-width: 28px; height: 28px; padding: 0 0.6rem; background: #6c757d; color: white; border-radius: 6px; font-size: 0.85rem; font-weight: 600; }
    .btn-collapse { background: transparent; border: none; color: #6c757d; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; transition: color 0.2s; }
    .btn-collapse:hover { color: #2b2b2b; }
    .section-content { transition: max-height 0.3s ease, opacity 0.3s ease; overflow: hidden; }
    .section-content.collapsed { max-height: 0 !important; opacity: 0; }
    
    .card { background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.25rem; transition: box-shadow 0.2s; }
    .card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
    .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.25rem; }
    .card-title { font-size: 1.05rem; font-weight: 600; color: #1a4d2e; margin: 0; }
    .card-actions { display: flex; gap: 0.5rem; }
    
    .option-row { display: grid; grid-template-columns: 110px 1fr auto; gap: 0.75rem; margin-bottom: 0.75rem; align-items: center; }
    
    .question-selector { margin: 1rem 0; padding: 1.25rem; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; }
    .question-selector-title { font-size: 0.9rem; font-weight: 600; margin-bottom: 0.75rem; color: #5a5a5a; }
    .question-chips { display: flex; flex-wrap: wrap; gap: 0.6rem; }
    .chip { padding: 0.5rem 1rem; background: white; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; font-size: 0.88rem; font-weight: 500; transition: all 0.2s; user-select: none; }
    .chip:hover { border-color: #1a4d2e; transform: translateY(-1px); }
    .chip.selected { background: #1a4d2e; color: white; border-color: #1a4d2e; }
    
    .preview-section { margin-top: 2rem; }
    .preview { background: #1e1e1e; color: #d4d4d4; padding: 1.5rem; border-radius: 10px; overflow: auto; max-height: 550px; }
    .preview pre { margin: 0; font-family: 'Courier New', monospace; font-size: 0.88rem; line-height: 1.5; white-space: pre-wrap; }
    
    .empty-state { text-align: center; padding: 2rem; color: #6c757d; background: #f8f9fa; border-radius: 8px; }
    .empty-state-icon { font-size: 2.5rem; margin-bottom: 0.75rem; opacity: 0.4; }
    
    input[type="file"] { display: none; }
    
    /* Import Modal */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 1000; overflow-y: auto; }
    .modal-overlay.active { display: flex; }
    .modal { background: white; border-radius: 12px; max-width: 1400px; width: 95%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); margin: 2rem auto; }
    .modal-header { padding: 1.5rem 2rem; border-bottom: 1px solid #e0e0e0; background: #1a4d2e; color: white; border-radius: 12px 12px 0 0; }
    .modal-header h2 { margin: 0; font-size: 1.5rem; }
    .modal-body { padding: 2rem; }
    .modal-footer { padding: 1rem 2rem; border-top: 1px solid #e0e0e0; display: flex; gap: 1rem; justify-content: flex-end; background: #f8f9fa; }
    .import-textarea { width: 100%; min-height: 200px; padding: 1rem; border: 2px dashed #d0d0d0; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical; }
    .import-preview { margin-top: 1.5rem; max-height: 300px; overflow-y: auto; }
    .import-preview table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
    .import-preview th { background: #1a4d2e; color: white; padding: 0.75rem; text-align: left; position: sticky; top: 0; }
    .import-preview td { padding: 0.75rem; border-bottom: 1px solid #e0e0e0; }
    .import-preview tr:hover { background: #f8f9fa; }
    .import-stats { background: #e8f5e9; border: 1px solid #1a4d2e; border-radius: 8px; padding: 1rem; margin: 1rem 0; }
    .import-stats-item { margin: 0.5rem 0; color: #1a4d2e; font-weight: 500; }
    .help-text { background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 1rem; margin: 1rem 0; font-size: 0.9rem; }
    .help-text strong { display: block; margin-bottom: 0.5rem; color: #856404; }
    .help-text code { background: #fff; padding: 0.2rem 0.4rem; border-radius: 3px; font-family: 'Courier New', monospace; font-size: 0.85rem; color: #d63384; }
  </style>
</head>
<body style="scroll-behavior: smooth;">
  <div class="container">
    <div class="toolbar">
      <div class="toolbar-row">
        <button class="btn btn-success" id="btn-save-server">☁️ Salvar</button>
        <button class="btn btn-secondary" id="btn-sample" title="Preencher exemplo rápido">Exemplo</button>
        <span class="toolbar-separator">|</span>
        <span class="toolbar-label">Preview:</span>
        <select id="preview-scenario" style="padding: 0.6rem 0.8rem; border-radius: 6px; border: 1px solid #d0d0d0; font-size: 0.9rem; font-weight: 500; background: white;">
          <option value="random">Respostas Aleatórias</option>
          <option value="min">Pontuação Mínima</option>
          <option value="max">Pontuação Máxima</option>
          <option value="mid">Pontuação Média</option>
        </select>
        <button class="btn btn-secondary" id="btn-preview-results">Ver</button>
        <button class="btn btn-secondary" id="btn-clear" title="Limpar tudo">Limpar</button>
      </div>
    </div>

    <div class="content">
      <!-- BASIC INFO -->
      <div class="grid">
        <div>
          <div class="field">
            <label for="test-title">Título <span style="color:#dc3545">*</span></label>
            <input id="test-title" placeholder="Escala de Ansiedade Generalizada">
          </div>
          <div class="field">
            <label for="test-id">ID do Teste <small style="color:#6c757d;font-weight:normal;">(gerado automaticamente)</small></label>
            <input id="test-id" readonly style="background:#f8f9fa;cursor:not-allowed;">
          </div>
          <div class="field">
            <label for="test-tag">Categoria / Tag</label>
            <input id="test-tag" placeholder="Ansiedade, Depressão, Personalidade">
          </div>
          <div class="field">
            <label for="article-url">Link do Artigo Científico</label>
            <input id="article-url" type="url" placeholder="https://pubmed.ncbi.nlm.nih.gov/...">
          </div>
          <div class="field">
            <label for="video-url">Link do Vídeo (Wistia)</label>
            <input id="video-url" type="url" placeholder="https://luisfca.wistia.com/medias/r9ja6ay4hi">
          </div>
          <div class="field">
            <label for="test-category">Categoria do Teste</label>
            <select id="test-category">
              <option value="para-voce">Para você</option>
              <option value="para-seu-filho">Para seu filho</option>
            </select>
          </div>
        </div>
        <div>
          <div class="field">
            <label for="test-desc">Descrição <span style="color:#dc3545">*</span></label>
            <div class="formatting-toolbar">
              <button type="button" class="btn-format" onclick="insertFormatting('test-desc', '**', '**')" title="Negrito"><strong>B</strong></button>
              <button type="button" class="btn-format" onclick="insertFormatting('test-desc', '*', '*')" title="Itálico"><em>I</em></button>
            </div>
            <textarea id="test-desc" class="tall" placeholder="Descrição breve que aparece no catálogo de testes"></textarea>
          </div>
          <div class="field">
            <label for="test-instr">Instruções para o Usuário <span style="color:#dc3545">*</span></label>
            <div class="formatting-toolbar">
              <button type="button" class="btn-format" onclick="insertFormatting('test-instr', '**', '**')" title="Negrito"><strong>B</strong></button>
              <button type="button" class="btn-format" onclick="insertFormatting('test-instr', '*', '*')" title="Itálico"><em>I</em></button>
            </div>
            <textarea id="test-instr" class="tall" placeholder="Instruções que aparecem antes do usuário começar o teste"></textarea>
          </div>
          <div class="field">
            <label for="est-time">Tempo Estimado</label>
            <input id="est-time" placeholder="3-5 min, 10-15 min">
          </div>
          <div class="field">
            <label>Configurações</label>
            <div class="checkbox-group">
              <label class="checkbox-label">
                <input type="checkbox" id="featured">
                <span>⭐ Destaque na homepage</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="curadoria">
                <span>✓ Curadoria Anova</span>
              </label>
            </div>
          </div>
        </div>
      </div>

      <div class="field">
        <label for="test-visibility">Visibilidade</label>
        <select id="test-visibility">
          <option value="public">Público (mostrar no catálogo)</option>
          <option value="hidden">Oculto (não mostrar no catálogo)</option>
        </select>
      </div>

      <!-- QUESTIONS -->
      <div class="section">
        <div class="section-header">
          <div class="section-header-left">
            <button class="btn-collapse" id="btn-collapse-questions" title="Ocultar/Mostrar">▼</button>
            <h3>Questões <span class="badge" id="q-count">0</span></h3>
          </div>
          <div style="display: flex; gap: 0.5rem;">
            <button class="btn btn-success" id="btn-import-questions">📥 Importar Questões</button>
            <button class="btn btn-primary" id="btn-add-question">+ Adicionar Questão</button>
          </div>
        </div>
        <div id="questions-list" class="section-content">
          <div class="empty-state">
            <div class="empty-state-icon">📝</div>
            <p>Nenhuma questão adicionada.</p>
          </div>
        </div>
      </div>

      <!-- FACTORS -->
      <div class="section">
        <div class="section-header">
          <div class="section-header-left">
            <button class="btn-collapse" id="btn-collapse-factors" title="Ocultar/Mostrar">▼</button>
            <h3>Fatores / Domínios <span class="badge" id="f-count">0</span></h3>
          </div>
          <div style="display: flex; gap: 0.5rem;">
            <button class="btn btn-success" id="btn-auto-quartile" title="Gerar fator geral com quartis automaticamente">📊 Usar Fator Geral e Quartis</button>
            <button class="btn btn-primary" id="btn-add-factor">+ Adicionar Fator</button>
          </div>
        </div>
        <div id="import-info" style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem; font-size: 0.9rem; color: #1565c0; display: none;">
          ℹ️ As interpretações foram calculadas com base em quartis. Caso haja interpretações específicas, <a href="#" id="clear-factors-link" style="color: #1565c0; font-weight: 600; text-decoration: underline; cursor: pointer;">clique aqui</a> e adicione manualmente.
        </div>
        <div id="manual-quartile-info" style="background: #e8f5e9; border: 1px solid #1a4d2e; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem; font-size: 0.9rem; color: #1a4d2e; display: none;">
          ✅ Fator Geral criado automaticamente com base em quartis. Para testes não normatizados, essa é uma forma rápida de obter interpretações.
        </div>
        <div id="factors-list" class="section-content">
          <div class="empty-state">
            <div class="empty-state-icon">📊</div>
            <p>Nenhum fator definido.</p>
          </div>
        </div>
      </div>

      <!-- PREVIEW -->
      <div id="preview-section" class="preview-section" style="display:none;">
        <div class="section-header">
          <h3>📄 Pré-visualização JSON</h3>
          <div class="card-actions" style="gap:0.5rem;">
            <button class="btn btn-secondary btn-small" id="btn-copy">📋 Copiar JSON</button>
            <button class="btn btn-secondary" id="btn-close-preview">✕ Fechar</button>
          </div>
        </div>
        <div class="preview">
          <pre id="preview-content"></pre>
        </div>
      </div>
    </div>
  </div>

  <!-- Import Modal -->
  <div class="modal-overlay" id="import-modal">
    <div class="modal">
      <div class="modal-header">
        <h2>📥 Importar Questões do Excel</h2>
      </div>
      <div class="modal-body">
        <div class="help-text">
          <strong>📋 Como usar:</strong>
          1. No Excel, inclua a linha de cabeçalho: <code>item | pergunta | resposta | peso | reversa | fator_geral | fator_especifico</code><br>
          2. Preencha suas questões (a primeira linha será ignorada automaticamente)<br>
          3. Na coluna "resposta", use formato: <code>1 Texto; 2 Texto; 3 Texto...</code><br>
          4. Selecione tudo (incluindo cabeçalho) e copie com Ctrl+C<br>
          5. Cole aqui com Ctrl+V<br>
          6. Revise a pré-visualização e clique em "Importar"
        </div>

        <div class="field">
          <label>Cole os dados do Excel aqui:</label>
          <textarea id="import-data" class="import-textarea" placeholder="Cole aqui (Ctrl+V)..."></textarea>
        </div>

        <div id="import-preview" class="import-preview" style="display:none;"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="btn-cancel-import">Cancelar</button>
        <button class="btn btn-success" id="btn-confirm-import" disabled>Importar</button>
      </div>
    </div>
  </div>

  <script>
    // ========== FORMATTING HELPER ==========
    function insertFormatting(textareaId, openTag, closeTag) {
      const textarea = document.getElementById(textareaId);
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const text = textarea.value;
      const selectedText = text.substring(start, end);
      
      // Insert formatting tags around selection
      const before = text.substring(0, start);
      const after = text.substring(end);
      const newText = before + openTag + selectedText + closeTag + after;
      
      textarea.value = newText;
      
      // Set cursor position after the inserted text
      const newCursorPos = selectedText ? end + openTag.length + closeTag.length : start + openTag.length;
      textarea.setSelectionRange(newCursorPos, newCursorPos);
      textarea.focus();
    }
    
    // ========== BULK IMPORT SYSTEM ==========
    let parsedImportData = null;

    function openImportModal() {
      document.getElementById('import-modal').classList.add('active');
      document.getElementById('import-data').value = '';
      document.getElementById('import-preview').style.display = 'none';
      
      // Reset button to "Importar"
      const confirmBtn = document.getElementById('btn-confirm-import');
      confirmBtn.textContent = 'Importar';
      confirmBtn.disabled = true;
      confirmBtn.onclick = executeImport;
      
      parsedImportData = null;
    }

    function closeImportModal() {
      document.getElementById('import-modal').classList.remove('active');
    }

    function parseImportData(rawData) {
      const lines = rawData.trim().split('\n');
      const questions = [];
      const factorGeneralItems = [];
      const factorSpecificMap = new Map();
      let reverseCount = 0;
      let weightedCount = 0;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line.trim()) continue;
        
        // Skip first line (header)
        if (i === 0) continue;
        
        // Split by tab
        const cols = line.split('\t').map(c => c.trim());
        
        if (cols.length < 3) continue; // Need at least item, question, and response
        
        const item = parseInt(cols[0]) || questions.length + 1;
        const questionText = cols[1] || '';
        const responseOptions = cols[2] || '';
        const weight = parseInt(cols[3]) || 1;
        const isReverse = (cols[4] || '').toUpperCase() === 'R';
        const inGeneralFactor = (cols[5] || '').toUpperCase() === 'S';
        const specificFactor = (cols[6] || '').trim();

        if (!questionText || !responseOptions) continue;

        // Parse response options (format: "1 Text; 2 Text; 3 Text")
        const options = [];
        const optionParts = responseOptions.split(';').map(o => o.trim());
        
        for (const part of optionParts) {
          if (!part) continue;
          // Extract value (first number) and text (everything after first space)
          const match = part.match(/^(\d+)\s+(.+)$/);
          if (match) {
            options.push({
              value: parseInt(match[1]),
              text: match[2].trim()
            });
          }
        }

        if (options.length === 0) continue; // Skip if no valid options

        if (weight > 1) weightedCount++;
        if (isReverse) reverseCount++;

        const question = {
          id: item,
          title: questionText,
          options: options,
          weight: weight,
          reverse: isReverse,
          inGeneralFactor: inGeneralFactor,
          specificFactor: specificFactor
        };

        questions.push(question);

        // Track factors
        if (inGeneralFactor) {
          factorGeneralItems.push(item);
        }
        if (specificFactor) {
          if (!factorSpecificMap.has(specificFactor)) {
            factorSpecificMap.set(specificFactor, []);
          }
          factorSpecificMap.get(specificFactor).push(item);
        }
      }

      return {
        questions,
        factorGeneralItems,
        factorSpecificMap,
        reverseCount,
        weightedCount,
        stats: {
          totalQuestions: questions.length,
          hasGeneralFactor: factorGeneralItems.length > 0,
          specificFactors: Array.from(factorSpecificMap.keys())
        }
      };
    }

    function previewImportData() {
      const rawData = document.getElementById('import-data').value;
      if (!rawData.trim()) {
        document.getElementById('import-preview').style.display = 'none';
        document.getElementById('btn-confirm-import').disabled = true;
        return;
      }

      try {
        parsedImportData = parseImportData(rawData);
        
        if (parsedImportData.questions.length === 0) {
          throw new Error('Nenhuma questão válida encontrada');
        }

        // Show stats
        let html = '<div class="import-stats">';
        html += `<div class="import-stats-item">✅ ${parsedImportData.stats.totalQuestions} questões detectadas</div>`;
        if (parsedImportData.reverseCount > 0) {
          html += `<div class="import-stats-item">✅ ${parsedImportData.reverseCount} questões com pontuação reversa</div>`;
        }
        if (parsedImportData.weightedCount > 0) {
          html += `<div class="import-stats-item">✅ ${parsedImportData.weightedCount} questões com peso diferenciado</div>`;
        }
        if (parsedImportData.stats.hasGeneralFactor) {
          html += `<div class="import-stats-item">✅ Fator Geral: ${parsedImportData.factorGeneralItems.length} questões</div>`;
        }
        if (parsedImportData.stats.specificFactors.length > 0) {
          html += `<div class="import-stats-item">✅ ${parsedImportData.stats.specificFactors.length} fatores específicos encontrados:</div>`;
          parsedImportData.stats.specificFactors.forEach(name => {
            const count = parsedImportData.factorSpecificMap.get(name).length;
            html += `<div class="import-stats-item" style="margin-left: 2rem;">• ${name} (${count} questões)</div>`;
          });
        }
        html += '</div>';

        // Show table preview
        html += '<table><thead><tr>';
        html += '<th>#</th><th>Pergunta</th><th>Opções</th><th>Peso</th><th>Rev</th><th>Geral</th><th>Específico</th>';
        html += '</tr></thead><tbody>';
        
        parsedImportData.questions.slice(0, 10).forEach(q => {
          const reverseStyle = q.reverse ? 'background: #ffe0e0; color: #ff6b6b; font-weight: 700;' : '';
          const weightStyle = q.weight > 1 ? 'background: #e0f2ff; color: #4dabf7; font-weight: 700;' : '';
          
          html += `<tr style="${reverseStyle}">`;
          html += `<td>${q.id}</td>`;
          html += `<td>${q.title.substring(0, 40)}${q.title.length > 40 ? '...' : ''}</td>`;
          html += `<td>${q.options.length} opções (${Math.min(...q.options.map(o => o.value))}-${Math.max(...q.options.map(o => o.value))})</td>`;
          html += `<td style="${weightStyle}">${q.weight}${q.weight > 1 ? 'x' : ''}</td>`;
          html += `<td style="font-size: 1.2rem;">${q.reverse ? '↩' : ''}</td>`;
          html += `<td>${q.inGeneralFactor ? 'S' : 'N'}</td>`;
          html += `<td>${q.specificFactor || '-'}</td>`;
          html += '</tr>';
        });
        
        if (parsedImportData.questions.length > 10) {
          html += `<tr><td colspan="6" style="text-align:center; color:#6c757d; font-style:italic;">... e mais ${parsedImportData.questions.length - 10} questões</td></tr>`;
        }
        
        html += '</tbody></table>';

        document.getElementById('import-preview').innerHTML = html;
        document.getElementById('import-preview').style.display = 'block';
        document.getElementById('btn-confirm-import').disabled = false;

      } catch (error) {
        alert('Erro ao processar dados: ' + error.message);
        document.getElementById('import-preview').style.display = 'none';
        document.getElementById('btn-confirm-import').disabled = true;
      }
    }

    function calculateQuartiles(min, max) {
      const range = max - min;
      const q1 = Math.floor(min + range * 0.25);
      const q2 = Math.floor(min + range * 0.50);
      const q3 = Math.floor(min + range * 0.75);
      
      return [
        { min: min, max: q1, level: 'Baixo', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **baixo**.' },
        { min: q1 + 1, max: q2, level: 'Médio', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **médio**.' },
        { min: q2 + 1, max: q3, level: 'Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **alto**.' },
        { min: q3 + 1, max: max, level: 'Muito Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **muito alto**.' }
      ];
    }

    function executeImport() {
      if (!parsedImportData) return;

      // Clear existing questions and factors
      state.questions = [];
      state.factors = [];
      qList.innerHTML = '';
      fList.innerHTML = '';

      // Create questions
      parsedImportData.questions.forEach(qData => {
        // Create question programmatically
        const qId = qData.id;
        
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'card-header';
        
        const title = document.createElement('div');
        title.className = 'card-title';
        title.textContent = `Questão ${qId}`;
        
        // Add reverse indicator if needed
        if (qData.reverse) {
          const reverseTag = document.createElement('span');
          reverseTag.style.cssText = 'margin-left: 0.5rem; padding: 0.2rem 0.5rem; background: #ff6b6b; color: white; font-size: 0.75rem; border-radius: 4px; font-weight: 600;';
          reverseTag.textContent = 'REVERSA';
          title.appendChild(reverseTag);
        }
        
        // Add weight indicator if > 1
        if (qData.weight && qData.weight > 1) {
          const weightTag = document.createElement('span');
          weightTag.style.cssText = 'margin-left: 0.5rem; padding: 0.2rem 0.5rem; background: #4dabf7; color: white; font-size: 0.75rem; border-radius: 4px; font-weight: 600;';
          weightTag.textContent = `PESO ${qData.weight}x`;
          title.appendChild(weightTag);
        }
        
        const actions = document.createElement('div');
        actions.className = 'card-actions';
        
        header.appendChild(title);
        header.appendChild(actions);

        // Create entry object first
        const entry = {
          id: qId,
          options: []
        };

        // Title input
        const titleField = document.createElement('div');
        titleField.className = 'field';
        titleField.innerHTML = '<label>Título da Questão</label>';
        const titleInput = document.createElement('input');
        titleInput.value = qData.title;
        titleField.appendChild(titleInput);

        // Peso and Reversa fields
        const metaGrid = document.createElement('div');
        metaGrid.style.cssText = 'display: grid; grid-template-columns: 150px 150px; gap: 1rem; margin-bottom: 1rem;';
        
        const pesoField = document.createElement('div');
        pesoField.className = 'field';
        pesoField.style.marginBottom = '0';
        pesoField.innerHTML = '<label>Peso</label>';
        const pesoInput = document.createElement('input');
        pesoInput.type = 'number';
        pesoInput.min = '1';
        pesoInput.value = qData.weight || 1;
        pesoInput.style.width = '100%';
        pesoField.appendChild(pesoInput);
        
        const reversaField = document.createElement('div');
        reversaField.className = 'field';
        reversaField.style.marginBottom = '0';
        reversaField.innerHTML = '<label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"><input type="checkbox" id="rev-${qId}" style="width: auto; cursor: pointer;"> Reversa</label>';
        const reversaCheckbox = reversaField.querySelector('input');
        reversaCheckbox.checked = qData.reverse || false;
        
        metaGrid.appendChild(pesoField);
        metaGrid.appendChild(reversaField);
        
        // Update badges when peso/reversa change
        function updateBadges() {
          // Remove existing badges
          title.querySelectorAll('span').forEach(s => s.remove());
          
          // Add reverse badge if checked
          if (reversaCheckbox.checked) {
            const reverseTag = document.createElement('span');
            reverseTag.style.cssText = 'margin-left: 0.5rem; padding: 0.2rem 0.5rem; background: #ff6b6b; color: white; font-size: 0.75rem; border-radius: 4px; font-weight: 600;';
            reverseTag.textContent = 'REVERSA';
            title.appendChild(reverseTag);
          }
          
          // Add weight badge if > 1
          const peso = Number(pesoInput.value) || 1;
          if (peso > 1) {
            const weightTag = document.createElement('span');
            weightTag.style.cssText = 'margin-left: 0.5rem; padding: 0.2rem 0.5rem; background: #4dabf7; color: white; font-size: 0.75rem; border-radius: 4px; font-weight: 600;';
            weightTag.textContent = `PESO ${peso}x`;
            title.appendChild(weightTag);
          }
        }
        
        pesoInput.addEventListener('input', updateBadges);
        reversaCheckbox.addEventListener('change', updateBadges);
        
        // Call once to set initial state
        updateBadges();
        
        // Store references
        entry.pesoInput = pesoInput;
        entry.reversaCheckbox = reversaCheckbox;

        // Type select
        const typeField = document.createElement('div');
        typeField.className = 'field';
        typeField.innerHTML = '<label>Tipo de Resposta</label>';
        const typeSelect = document.createElement('select');
        typeSelect.innerHTML = `
          <option value="single">Escolha Única</option>
          <option value="likert" selected>Likert</option>
          <option value="yesno">Sim/Não</option>
          <option value="scale">Escala Numérica</option>
        `;
        typeSelect.value = 'likert';
        typeField.appendChild(typeSelect);

        // Options container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'field';
        optionsContainer.innerHTML = '<label>Opções de Resposta</label>';
        optionsContainer.style.display = 'block';

        // Scale container (hidden for likert)
        const scaleContainer = document.createElement('div');
        scaleContainer.style.display = 'none';

        const btnAddOption = document.createElement('button');
        btnAddOption.className = 'btn btn-secondary btn-small';
        btnAddOption.textContent = '+ Adicionar Opção';
        btnAddOption.type = 'button';
        btnAddOption.style.display = 'block';

        // Complete entry object
        entry.titleInput = titleInput;
        entry.typeSelect = typeSelect;
        entry.optionsContainer = optionsContainer;
        entry.scaleContainer = scaleContainer;
        entry.card = card;
        entry.weight = qData.weight || 1;
        entry.reverse = qData.reverse || false;

        state.questions.push(entry);

        // Add options from parsed data
        qData.options.forEach(opt => {
          const row = document.createElement('div');
          row.className = 'option-row';

          const valueInput = document.createElement('input');
          valueInput.type = 'number';
          valueInput.value = opt.value;
          valueInput.placeholder = 'Valor';

          const textInput = document.createElement('input');
          textInput.type = 'text';
          textInput.value = opt.text;
          textInput.placeholder = 'Texto da opção';

          const btnRemove = document.createElement('button');
          btnRemove.className = 'btn btn-danger btn-small';
          btnRemove.textContent = '✕';
          btnRemove.type = 'button';
          btnRemove.addEventListener('click', () => {
            entry.options = entry.options.filter(o => o.row !== row);
            row.remove();
          });

          row.appendChild(valueInput);
          row.appendChild(textInput);
          row.appendChild(btnRemove);

          optionsContainer.appendChild(row);

          entry.options.push({ valueInput, textInput, row });
        });

        btnAddOption.addEventListener('click', () => {
          const row = document.createElement('div');
          row.className = 'option-row';

          const valueInput = document.createElement('input');
          valueInput.type = 'number';
          valueInput.placeholder = 'Valor';

          const textInput = document.createElement('input');
          textInput.type = 'text';
          textInput.placeholder = 'Texto da opção';

          const btnRemove = document.createElement('button');
          btnRemove.className = 'btn btn-danger btn-small';
          btnRemove.textContent = '✕';
          btnRemove.type = 'button';
          btnRemove.addEventListener('click', () => {
            entry.options = entry.options.filter(o => o.row !== row);
            row.remove();
          });

          row.appendChild(valueInput);
          row.appendChild(textInput);
          row.appendChild(btnRemove);

          optionsContainer.appendChild(row);
          entry.options.push({ valueInput, textInput, row });
        });

        // Duplicate button
        const btnDuplicate = document.createElement('button');
        btnDuplicate.className = 'btn btn-secondary btn-small';
        btnDuplicate.textContent = '📋';
        btnDuplicate.title = 'Duplicar questão';
        btnDuplicate.addEventListener('click', () => {
          addQuestion({
            title: titleInput.value,
            type: 'likert',
            options: entry.options.map(o => ({ 
              value: o.valueInput.value, 
              text: o.textInput.value 
            }))
          });
        });

        // Remove button
        const btnRemove = document.createElement('button');
        btnRemove.className = 'btn btn-danger btn-small';
        btnRemove.textContent = '🗑️';
        btnRemove.title = 'Remover questão';
        btnRemove.addEventListener('click', () => {
          if (confirm('Remover esta questão?')) {
            state.questions = state.questions.filter(q => q !== entry);
            card.remove();
            updateCounts();
            updateFactorSelectors();
          }
        });

        actions.appendChild(btnDuplicate);
        actions.appendChild(btnRemove);

        // Assemble card
        card.appendChild(header);
        card.appendChild(titleField);
        card.appendChild(metaGrid);
        card.appendChild(typeField);
        card.appendChild(optionsContainer);
        card.appendChild(scaleContainer);
        card.appendChild(btnAddOption);

        qList.appendChild(card);
      });

      // Create factors
      // 1. General Factor (if any)
      if (parsedImportData.stats.hasGeneralFactor) {
        let minVal = 0;
        let maxVal = 0;
        
        parsedImportData.factorGeneralItems.forEach(qId => {
          const q = parsedImportData.questions.find(q => q.id === qId);
          if (q && q.options.length > 0) {
            const weight = q.weight || 1;
            const qMin = Math.min(...q.options.map(o => o.value)) * weight;
            const qMax = Math.max(...q.options.map(o => o.value)) * weight;
            minVal += qMin;
            maxVal += qMax;
          }
        });
        
        const quartiles = calculateQuartiles(minVal, maxVal);
        
        addFactorProgrammatically('fator-geral', 'Fator Geral', parsedImportData.factorGeneralItems, quartiles);
      }

      // 2. Specific Factors
      parsedImportData.stats.specificFactors.forEach(factorName => {
        const questionIds = parsedImportData.factorSpecificMap.get(factorName);
        let minVal = 0;
        let maxVal = 0;
        
        questionIds.forEach(qId => {
          const q = parsedImportData.questions.find(q => q.id === qId);
          if (q && q.options.length > 0) {
            const weight = q.weight || 1;
            const qMin = Math.min(...q.options.map(o => o.value)) * weight;
            const qMax = Math.max(...q.options.map(o => o.value)) * weight;
            minVal += qMin;
            maxVal += qMax;
          }
        });
        
        const quartiles = calculateQuartiles(minVal, maxVal);
        
        const factorId = factorName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
        addFactorProgrammatically(factorId, factorName, questionIds, quartiles);
      });

      updateCounts();
      updateFactorSelectors();
      
      // Update question ID counter
      if (parsedImportData.questions.length > 0) {
        questionIdCounter = Math.max(...parsedImportData.questions.map(q => q.id)) + 1;
      }
      
      // Close modal immediately
      closeImportModal();
      
      // Collapse questions section
      const questionsList = document.getElementById('questions-list');
      const btnCollapseQuestions = document.getElementById('btn-collapse-questions');
      questionsList.classList.add('collapsed');
      btnCollapseQuestions.textContent = '▶';
      
      // Collapse factors section
      const factorsList = document.getElementById('factors-list');
      const btnCollapseFactors = document.getElementById('btn-collapse-factors');
      factorsList.classList.add('collapsed');
      btnCollapseFactors.textContent = '▶';
      
      // Show import info message
      document.getElementById('import-info').style.display = 'block';
    }

    function addFactorProgrammatically(id, name, questionIds, ranges) {
      const card = document.createElement('div');
      card.className = 'card';

      const header = document.createElement('div');
      header.className = 'card-header';
      
      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = name;
      
      const actions = document.createElement('div');
      actions.className = 'card-actions';
      
      header.appendChild(title);
      header.appendChild(actions);

      // ID field
      const idField = document.createElement('div');
      idField.className = 'field';
      idField.innerHTML = '<label>ID do Fator (único, sem espaços)</label>';
      const idInput = document.createElement('input');
      idInput.value = id;
      idInput.placeholder = 'ex: fator-ansiedade';
      idField.appendChild(idInput);

      // Name field
      const nameField = document.createElement('div');
      nameField.className = 'field';
      nameField.innerHTML = '<label>Nome do Fator</label>';
      const nameInput = document.createElement('input');
      nameInput.value = name;
      nameInput.placeholder = 'ex: Ansiedade Geral';
      nameField.appendChild(nameInput);

      // Question selector
      const selector = document.createElement('div');
      selector.className = 'question-selector';
      selector.innerHTML = '<div class="question-selector-title">Questões incluídas:</div>';
      const chips = document.createElement('div');
      chips.className = 'question-chips';
      chips.setAttribute('data-chips', '');
      selector.appendChild(chips);

      // Ranges
      const rangesLabel = document.createElement('div');
      rangesLabel.className = 'field';
      rangesLabel.innerHTML = '<label>Faixas de Pontuação</label>';
      
      const rangesContainer = document.createElement('div');
      
      const btnAddRange = document.createElement('button');
      btnAddRange.className = 'btn btn-secondary btn-small';
      btnAddRange.textContent = '+ Adicionar Faixa';
      btnAddRange.type = 'button';

      const entry = {
        idInput,
        nameInput,
        questionSelector: selector,
        selectedQuestions: questionIds || [],
        ranges: [],
        rangesContainer,
        card
      };

      state.factors.push(entry);

      // Add ranges
      ranges.forEach(r => {
        addRangeProgrammatically(entry, r.min, r.max, r.level, r.description);
      });

      btnAddRange.addEventListener('click', () => {
        addRangeProgrammatically(entry, 0, 10, 'Nível', 'Descrição do resultado');
      });

      // Remove button
      const btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-danger btn-small';
      btnRemove.textContent = '🗑️';
      btnRemove.title = 'Remover fator';
      btnRemove.addEventListener('click', () => {
        if (confirm('Remover este fator?')) {
          state.factors = state.factors.filter(f => f !== entry);
          card.remove();
          updateCounts();
        }
      });

      actions.appendChild(btnRemove);

      card.appendChild(header);
      card.appendChild(idField);
      card.appendChild(nameField);
      card.appendChild(selector);
      card.appendChild(rangesLabel);
      card.appendChild(rangesContainer);
      card.appendChild(btnAddRange);

      fList.appendChild(card);
      
      updateFactorSelectors();
    }

    // ========== AUTO QUARTILE GENERATION (FOR MANUAL TESTS) ==========
    function generateAutoQuartileFactor() {
      // Check if there are questions
      if (state.questions.length === 0) {
        alert('Adicione questões primeiro antes de gerar o fator geral.');
        return;
      }
      
      // Check if factor already exists
      if (state.factors.length > 0) {
        if (!confirm('Já existem fatores configurados. Deseja substituí-los pelo Fator Geral automático?')) {
          return;
        }
        // Clear existing factors
        state.factors = [];
        fList.innerHTML = '';
      }
      
      // Calculate min and max scores
      let minVal = 0;
      let maxVal = 0;
      const allQuestionIds = [];
      
      state.questions.forEach(q => {
        allQuestionIds.push(q.id);
        
        if (q.options && q.options.length > 0) {
          const weight = q.pesoInput ? Number(q.pesoInput.value) || 1 : 1;
          const values = q.options.map(o => Number(o.valueInput.value) || 0);
          const qMin = Math.min(...values) * weight;
          const qMax = Math.max(...values) * weight;
          minVal += qMin;
          maxVal += qMax;
        } else if (q.minInput && q.maxInput) {
          // For scale type questions
          const weight = q.pesoInput ? Number(q.pesoInput.value) || 1 : 1;
          minVal += Number(q.minInput.value) * weight;
          maxVal += Number(q.maxInput.value) * weight;
        }
      });
      
      // Calculate quartiles
      const quartiles = calculateQuartiles(minVal, maxVal);
      
      // Create the general factor
      addFactorProgrammatically('fator-geral', 'Fator Geral', allQuestionIds, quartiles);
      
      // Show info message
      document.getElementById('manual-quartile-info').style.display = 'block';
      document.getElementById('import-info').style.display = 'none';
      
      // Collapse the factors section to keep it clean
      const factorsList = document.getElementById('factors-list');
      const btnCollapseFactors = document.getElementById('btn-collapse-factors');
      factorsList.classList.add('collapsed');
      btnCollapseFactors.textContent = '▶';
      
      updateCounts();
      
      alert(`Fator Geral criado!\n\nPontuação: ${minVal} - ${maxVal}\nInterpretação: 4 níveis (Baixo, Médio, Alto, Muito Alto)\nQuestões incluídas: ${allQuestionIds.length}`);
    }
    
    function addRangeProgrammatically(factorEntry, min, max, level, desc) {
      const row = document.createElement('div');
      row.className = 'card';
      row.style.background = '#f8f9fa';
      row.style.padding = '1rem';
      row.style.marginBottom = '0.75rem';

      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = '100px 100px 150px 1fr auto';
      grid.style.gap = '0.75rem';
      grid.style.alignItems = 'start';

      const minInput = document.createElement('input');
      minInput.type = 'number';
      minInput.value = min;
      minInput.placeholder = 'Mín';

      const maxInput = document.createElement('input');
      maxInput.type = 'number';
      maxInput.value = max;
      maxInput.placeholder = 'Máx';

      const levelInput = document.createElement('input');
      levelInput.type = 'text';
      levelInput.value = level;
      levelInput.placeholder = 'Nível';

      const descInput = document.createElement('textarea');
      descInput.value = desc;
      descInput.placeholder = 'Descrição / interpretação';
      descInput.style.minHeight = '60px';

      const btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-danger btn-small';
      btnRemove.textContent = '✕';
      btnRemove.type = 'button';
      btnRemove.addEventListener('click', () => {
        factorEntry.ranges = factorEntry.ranges.filter(r => r.row !== row);
        row.remove();
      });

      grid.appendChild(minInput);
      grid.appendChild(maxInput);
      grid.appendChild(levelInput);
      grid.appendChild(descInput);
      grid.appendChild(btnRemove);

      row.appendChild(grid);
      factorEntry.rangesContainer.appendChild(row);

      factorEntry.ranges.push({ minInput, maxInput, levelInput, descInput, row });
    }
    
    // ========== STATE ==========
    const state = { questions: [], factors: [] };
    let questionIdCounter = 1;
    let existingTestIds = [];
    let existingCreatedAt = null; // Store createdAt for edit mode

    // ========== EDIT MODE DETECTION ==========
    const urlParams = new URLSearchParams(window.location.search);
    const editMode = urlParams.get('mode') === 'edit';
    const editTestId = urlParams.get('id');

    // ========== UI ELEMENTS ==========
    const qList = document.getElementById('questions-list');
    const fList = document.getElementById('factors-list');
    const qCount = document.getElementById('q-count');
    const fCount = document.getElementById('f-count');
    const previewSection = document.getElementById('preview-section');
    const previewContent = document.getElementById('preview-content');
    
    // Collapse toggle functionality
    document.getElementById('btn-collapse-questions').addEventListener('click', function() {
      const content = document.getElementById('questions-list');
      content.classList.toggle('collapsed');
      this.textContent = content.classList.contains('collapsed') ? '▶' : '▼';
    });
    
    document.getElementById('btn-collapse-factors').addEventListener('click', function() {
      const content = document.getElementById('factors-list');
      content.classList.toggle('collapsed');
      this.textContent = content.classList.contains('collapsed') ? '▶' : '▼';
    });
    
    // Auto quartile button
    document.getElementById('btn-auto-quartile').addEventListener('click', generateAutoQuartileFactor);

    // ========== HELPERS ==========
    function updateCounts() {
      qCount.textContent = state.questions.length;
      fCount.textContent = state.factors.length;
      
      // Remove empty states
      if (state.questions.length > 0) {
        const emptyState = qList.querySelector('.empty-state');
        if (emptyState) emptyState.remove();
      }
      if (state.factors.length > 0) {
        const emptyState = fList.querySelector('.empty-state');
        if (emptyState) emptyState.remove();
      }
    }

    function slugify(str) {
      return (str || '').toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');
    }
    
    // Auto-generate unique ID from title
    function generateUniqueId(title) {
      let baseId = slugify(title);
      if (!baseId) return '';
      
      // If in edit mode, allow keeping the same ID
      if (editMode && baseId === editTestId) {
        return baseId;
      }
      
      let uniqueId = baseId;
      let counter = 2;
      
      // Check for duplicates and add counter if needed
      while (existingTestIds.includes(uniqueId)) {
        uniqueId = `${baseId}-${counter}`;
        counter++;
      }
      
      return uniqueId;
    }
    
    // Fetch existing test IDs
    async function loadExistingTestIds() {
      try {
        const response = await fetch('/api/tests');
        const data = await response.json();
        if (data.success && data.tests) {
          existingTestIds = data.tests.map(t => t.id);
        }
      } catch (error) {
        console.error('Failed to load existing test IDs:', error);
      }
    }

    function collectData() {
      const get = id => document.getElementById(id)?.value.trim() || '';
      
      return {
        id: get('test-id'),
        title: get('test-title'),
        description: get('test-desc'),
        tag: get('test-tag'),
        category: get('test-category') || 'para-voce',
        articleUrl: get('article-url') || undefined,
        videoUrl: get('video-url') || undefined,
        featured: document.getElementById('featured')?.checked || false,
        curadoria: document.getElementById('curadoria')?.checked || false,
        testType: 'questionnaire',
        visibility: get('test-visibility') || 'public',
        isPremium: false,
        instructions: get('test-instr'),
        estimatedTime: get('est-time') || undefined,
        questionCount: state.questions.length,
        createdAt: existingCreatedAt || new Date().toISOString(), // Preserve existing or create new timestamp
        questions: state.questions.map(q => ({
          id: q.id,
          title: q.titleInput.value.trim(),
          type: q.typeSelect.value,
          options: (q.options || []).map(opt => ({
            value: Number(opt.valueInput.value),
            text: opt.textInput.value.trim()
          })),
          min: q.minInput?.value ? Number(q.minInput.value) : undefined,
          max: q.maxInput?.value ? Number(q.maxInput.value) : undefined,
          step: q.stepInput?.value ? Number(q.stepInput.value) : undefined,
          weight: q.pesoInput ? Number(q.pesoInput.value) || 1 : 1,
          reverse: q.reversaCheckbox ? q.reversaCheckbox.checked : false
        })),
        scoring: {
          min: 0,
          max: state.questions.reduce((sum, q) => {
            const qMax = Math.max(...(q.options || []).map(o => Number(o.valueInput?.value || 0)), 0);
            const weight = q.pesoInput ? Number(q.pesoInput.value) || 1 : 1;
            return sum + (qMax * weight);
          }, 0),
          factors: state.factors.map(f => ({
            id: f.idInput.value.trim() || slugify(f.nameInput.value),
            name: f.nameInput.value.trim(),
            questionIds: f.selectedQuestions || [],
            ranges: f.ranges.map(r => ({
              min: Number(r.minInput.value),
              max: Number(r.maxInput.value),
              level: r.levelInput.value.trim(),
              description: r.descInput.value.trim()
            }))
          }))
        }
      };
    }

    // ========== QUESTIONS ==========
    function addQuestion(data = null) {
      const qId = data?.id || questionIdCounter++;
      
      const card = document.createElement('div');
      card.className = 'card';

      // Header
      const header = document.createElement('div');
      header.className = 'card-header';
      
      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = `Questão ${qId}`;
      
      const actions = document.createElement('div');
      actions.className = 'card-actions';
      
      header.appendChild(title);
      header.appendChild(actions);

      // Title input
      const titleField = document.createElement('div');
      titleField.className = 'field';
      titleField.innerHTML = '<label>Título da Questão</label>';
      const titleInput = document.createElement('input');
      titleInput.placeholder = 'Ex: Como você tem se sentido nas últimas 2 semanas?';
      titleInput.value = data?.title || '';
      titleField.appendChild(titleInput);

      // Peso and Reversa fields
      const metaGrid = document.createElement('div');
      metaGrid.style.cssText = 'display: grid; grid-template-columns: 150px 150px; gap: 1rem; margin-bottom: 1rem;';
      
      const pesoField = document.createElement('div');
      pesoField.className = 'field';
      pesoField.style.marginBottom = '0';
      pesoField.innerHTML = '<label>Peso</label>';
      const pesoInput = document.createElement('input');
      pesoInput.type = 'number';
      pesoInput.min = '1';
      pesoInput.value = data?.weight || 1;
      pesoInput.style.width = '100%';
      pesoField.appendChild(pesoInput);
      
      const reversaField = document.createElement('div');
      reversaField.className = 'field';
      reversaField.style.marginBottom = '0';
      reversaField.innerHTML = `<label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"><input type="checkbox" id="rev-${qId}" style="width: auto; cursor: pointer;"> Reversa</label>`;
      const reversaCheckbox = reversaField.querySelector('input');
      reversaCheckbox.checked = data?.reverse || false;
      
      metaGrid.appendChild(pesoField);
      metaGrid.appendChild(reversaField);
      
      // Update badges when peso/reversa change
      function updateBadges() {
        // Remove existing badges
        title.querySelectorAll('span').forEach(s => s.remove());
        
        // Add reverse badge if checked
        if (reversaCheckbox.checked) {
          const reverseTag = document.createElement('span');
          reverseTag.style.cssText = 'margin-left: 0.5rem; padding: 0.2rem 0.5rem; background: #ff6b6b; color: white; font-size: 0.75rem; border-radius: 4px; font-weight: 600;';
          reverseTag.textContent = 'REVERSA';
          title.appendChild(reverseTag);
        }
        
        // Add weight badge if > 1
        const peso = Number(pesoInput.value) || 1;
        if (peso > 1) {
          const weightTag = document.createElement('span');
          weightTag.style.cssText = 'margin-left: 0.5rem; padding: 0.2rem 0.5rem; background: #4dabf7; color: white; font-size: 0.75rem; border-radius: 4px; font-weight: 600;';
          weightTag.textContent = `PESO ${peso}x`;
          title.appendChild(weightTag);
        }
      }
      
      pesoInput.addEventListener('input', updateBadges);
      reversaCheckbox.addEventListener('change', updateBadges);
      
      // Call once to set initial state
      updateBadges();

      // Type select
      const typeField = document.createElement('div');
      typeField.className = 'field';
      typeField.innerHTML = '<label>Tipo de Resposta</label>';
      const typeSelect = document.createElement('select');
      const types = [
        { value: 'single', label: 'Escolha Única' },
        { value: 'likert', label: 'Likert (1-5)' },
        { value: 'yesno', label: 'Sim/Não' },
        { value: 'scale', label: 'Escala Numérica' }
      ];
      types.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t.value;
        opt.textContent = t.label;
        typeSelect.appendChild(opt);
      });
      typeSelect.value = data?.type || 'single';
      typeField.appendChild(typeSelect);

      // Options container
      const optionsContainer = document.createElement('div');
      optionsContainer.style.marginTop = '1rem';

      // Scale inputs
      const scaleContainer = document.createElement('div');
      scaleContainer.style.display = 'none';
      scaleContainer.innerHTML = `
        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:1rem; margin-top:0.75rem;">
          <div class="field">
            <label>Valor Mínimo</label>
            <input type="number" class="scale-min" value="${data?.min || 0}">
          </div>
          <div class="field">
            <label>Valor Máximo</label>
            <input type="number" class="scale-max" value="${data?.max || 10}">
          </div>
          <div class="field">
            <label>Incremento</label>
            <input type="number" class="scale-step" value="${data?.step || 1}">
          </div>
        </div>
      `;
      const minInput = scaleContainer.querySelector('.scale-min');
      const maxInput = scaleContainer.querySelector('.scale-max');
      const stepInput = scaleContainer.querySelector('.scale-step');

      // Button to add options
      const btnAddOption = document.createElement('button');
      btnAddOption.className = 'btn btn-secondary btn-small';
      btnAddOption.textContent = '+ Adicionar Opção';
      btnAddOption.style.marginTop = '0.75rem';

      // Create entry object
      const entry = {
        id: qId,
        titleInput,
        typeSelect,
        options: [],
        optionsContainer,
        minInput,
        maxInput,
        stepInput,
        pesoInput,
        reversaCheckbox,
        card
      };

      state.questions.push(entry);

      // Type change handler
      typeSelect.addEventListener('change', () => {
        const type = typeSelect.value;
        const needsOptions = ['single', 'likert', 'yesno'].includes(type);
        
        optionsContainer.style.display = needsOptions ? 'block' : 'none';
        btnAddOption.style.display = needsOptions ? 'block' : 'none';
        scaleContainer.style.display = type === 'scale' ? 'block' : 'none';

        // Auto-populate Likert
        if (type === 'likert' && entry.options.length === 0) {
          for (let i = 1; i <= 5; i++) {
            addOption(entry, i, '');
          }
        }

        updateFactorSelectors();
      });

      btnAddOption.addEventListener('click', () => addOption(entry));

      // Duplicate button
      const btnDuplicate = document.createElement('button');
      btnDuplicate.className = 'btn btn-secondary btn-small';
      btnDuplicate.textContent = '📋';
      btnDuplicate.title = 'Duplicar questão';
      btnDuplicate.addEventListener('click', () => {
        addQuestion({
          title: titleInput.value,
          type: typeSelect.value,
          options: entry.options.map(o => ({ 
            value: o.valueInput.value, 
            text: o.textInput.value 
          })),
          min: minInput?.value,
          max: maxInput?.value,
          step: stepInput?.value,
          weight: pesoInput?.value,
          reverse: reversaCheckbox?.checked
        });
      });

      // Remove button
      const btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-danger btn-small';
      btnRemove.textContent = '🗑️';
      btnRemove.title = 'Remover questão';
      btnRemove.addEventListener('click', () => {
        if (confirm('Remover esta questão?')) {
          state.questions = state.questions.filter(q => q !== entry);
          card.remove();
          updateCounts();
          updateFactorSelectors();
        }
      });

      actions.appendChild(btnDuplicate);
      actions.appendChild(btnRemove);

      // Assemble card
      card.appendChild(header);
      card.appendChild(titleField);
      card.appendChild(metaGrid);
      card.appendChild(typeField);
      card.appendChild(optionsContainer);
      card.appendChild(scaleContainer);
      card.appendChild(btnAddOption);

      qList.appendChild(card);

      // Load existing options or defaults
      if (data?.options?.length) {
        data.options.forEach(o => addOption(entry, o.value, o.text));
      } else if (typeSelect.value === 'likert') {
        for (let i = 1; i <= 5; i++) {
          addOption(entry, i, '');
        }
      }

      // Set initial visibility
      const needsOptions = ['single', 'likert', 'yesno'].includes(typeSelect.value);
      optionsContainer.style.display = needsOptions ? 'block' : 'none';
      btnAddOption.style.display = needsOptions ? 'block' : 'none';
      scaleContainer.style.display = typeSelect.value === 'scale' ? 'block' : 'none';

      updateCounts();
      updateFactorSelectors();
    }

    function addOption(qEntry, defVal = 0, defText = '') {
      const row = document.createElement('div');
      row.className = 'option-row';

      const valueInput = document.createElement('input');
      valueInput.type = 'number';
      valueInput.value = defVal;
      valueInput.placeholder = 'Valor';
      valueInput.style.padding = '0.6rem';
      valueInput.style.border = '2px solid #e8e3db';
      valueInput.style.borderRadius = '6px';

      const textInput = document.createElement('input');
      textInput.value = defText;
      textInput.placeholder = 'Texto da opção de resposta';
      textInput.style.padding = '0.6rem';
      textInput.style.border = '2px solid #e8e3db';
      textInput.style.borderRadius = '6px';

      const btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-danger btn-small';
      btnRemove.textContent = '✕';
      btnRemove.addEventListener('click', () => {
        qEntry.options = qEntry.options.filter(o => o !== optEntry);
        row.remove();
      });

      const optEntry = { valueInput, textInput };
      qEntry.options.push(optEntry);

      row.appendChild(valueInput);
      row.appendChild(textInput);
      row.appendChild(btnRemove);
      qEntry.optionsContainer.appendChild(row);
    }

    // ========== FACTORS ==========
    function addFactor(data = null) {
      const card = document.createElement('div');
      card.className = 'card';

      // Header
      const header = document.createElement('div');
      header.className = 'card-header';
      header.innerHTML = '<div class="card-title">Fator / Domínio</div>';
      
      const btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-danger btn-small';
      btnRemove.textContent = '🗑️ Remover';
      btnRemove.addEventListener('click', () => {
        if (confirm('Remover este fator?')) {
          state.factors = state.factors.filter(f => f !== entry);
          card.remove();
          updateCounts();
        }
      });
      
      const actions = document.createElement('div');
      actions.className = 'card-actions';
      actions.appendChild(btnRemove);
      header.appendChild(actions);

      // Name input
      const nameField = document.createElement('div');
      nameField.className = 'field';
      nameField.innerHTML = '<label>Nome do Fator</label>';
      const nameInput = document.createElement('input');
      nameInput.placeholder = 'Ex: Extroversão, Neuroticismo, Ansiedade Social';
      nameInput.value = data?.name || '';
      nameField.appendChild(nameInput);

      // ID input
      const idField = document.createElement('div');
      idField.className = 'field';
      idField.innerHTML = '<label>ID do Fator (opcional)</label>';
      const idInput = document.createElement('input');
      idInput.placeholder = 'Gerado automaticamente se deixar em branco';
      idInput.value = data?.id || '';
      idField.appendChild(idInput);

      // Question selector
      const questionSelector = document.createElement('div');
      questionSelector.className = 'question-selector';
      questionSelector.innerHTML = `
        <div class="question-selector-title">
          Selecione as questões que compõem este fator:
        </div>
        <div class="question-chips" data-chips></div>
      `;

      // Ranges container
      const rangesContainer = document.createElement('div');
      rangesContainer.style.marginTop = '1.5rem';
      
      const rangesTitle = document.createElement('div');
      rangesTitle.style.fontWeight = '600';
      rangesTitle.style.marginBottom = '0.75rem';
      rangesTitle.textContent = 'Faixas de Interpretação:';
      rangesContainer.appendChild(rangesTitle);

      // Button to add range
      const btnAddRange = document.createElement('button');
      btnAddRange.className = 'btn btn-secondary btn-small';
      btnAddRange.textContent = '+ Adicionar Faixa';
      btnAddRange.style.marginTop = '0.75rem';

      // Create entry
      const entry = {
        nameInput,
        idInput,
        ranges: [],
        rangesContainer,
        questionSelector,
        selectedQuestions: data?.questionIds || []
      };

      state.factors.push(entry);

      btnAddRange.addEventListener('click', () => addRange(entry));

      // Assemble card
      card.appendChild(header);
      card.appendChild(nameField);
      card.appendChild(idField);
      card.appendChild(questionSelector);
      card.appendChild(rangesContainer);
      card.appendChild(btnAddRange);

      fList.appendChild(card);

      // Load existing ranges or add default
      if (data?.ranges?.length) {
        data.ranges.forEach(r => addRange(entry, r));
      } else {
        addRange(entry);
      }

      updateCounts();
      updateFactorQuestionSelector(entry);
    }

    function updateFactorSelectors() {
      state.factors.forEach(f => updateFactorQuestionSelector(f));
    }

    function updateFactorQuestionSelector(factorEntry) {
      const chipsContainer = factorEntry.questionSelector.querySelector('[data-chips]');
      chipsContainer.innerHTML = '';

      if (state.questions.length === 0) {
        chipsContainer.innerHTML = '<small style="color:#6c757d;">Adicione questões primeiro para selecionar</small>';
        return;
      }

      state.questions.forEach(q => {
        const chip = document.createElement('div');
        chip.className = 'chip';
        
        const title = q.titleInput.value.trim() || 'Sem título';
        const preview = title.length > 40 ? title.substring(0, 40) + '...' : title;
        chip.textContent = `Q${q.id}: ${preview}`;
        chip.title = title;

        if (factorEntry.selectedQuestions.includes(q.id)) {
          chip.classList.add('selected');
        }

        chip.addEventListener('click', () => {
          if (factorEntry.selectedQuestions.includes(q.id)) {
            factorEntry.selectedQuestions = factorEntry.selectedQuestions.filter(id => id !== q.id);
            chip.classList.remove('selected');
          } else {
            factorEntry.selectedQuestions.push(q.id);
            chip.classList.add('selected');
          }
        });

        chipsContainer.appendChild(chip);
      });
    }

    function addRange(factorEntry, data = null) {
      const rangeCard = document.createElement('div');
      rangeCard.style.background = 'white';
      rangeCard.style.border = '2px solid #e8e3db';
      rangeCard.style.borderRadius = '8px';
      rangeCard.style.padding = '1rem';
      rangeCard.style.marginBottom = '0.75rem';

      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = '100px 100px 1fr auto';
      grid.style.gap = '0.75rem';
      grid.style.alignItems = 'end';

      const minField = document.createElement('div');
      minField.className = 'field';
      minField.style.marginBottom = '0';
      minField.innerHTML = `
        <label>Mínimo</label>
        <input type="number" value="${data?.min || 0}">
      `;

      const maxField = document.createElement('div');
      maxField.className = 'field';
      maxField.style.marginBottom = '0';
      maxField.innerHTML = `
        <label>Máximo</label>
        <input type="number" value="${data?.max || 10}">
      `;

      const levelField = document.createElement('div');
      levelField.className = 'field';
      levelField.style.marginBottom = '0';
      levelField.innerHTML = `
        <label>Nível</label>
        <input value="${data?.level || ''}" placeholder="Baixo, Moderado, Alto">
      `;

      const minInput = minField.querySelector('input');
      const maxInput = maxField.querySelector('input');
      const levelInput = levelField.querySelector('input');

      const btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-danger btn-small';
      btnRemove.textContent = '✕';
      btnRemove.addEventListener('click', () => {
        factorEntry.ranges = factorEntry.ranges.filter(r => r !== rangeEntry);
        rangeCard.remove();
      });

      const descField = document.createElement('div');
      descField.className = 'field';
      descField.style.marginTop = '0.75rem';
      descField.style.marginBottom = '0';
      descField.innerHTML = `
        <label>Descrição / Interpretação</label>
        <textarea>${data?.description || ''}</textarea>
      `;
      const descInput = descField.querySelector('textarea');

      const rangeEntry = { minInput, maxInput, levelInput, descInput };
      factorEntry.ranges.push(rangeEntry);

      grid.appendChild(minField);
      grid.appendChild(maxField);
      grid.appendChild(levelField);
      grid.appendChild(btnRemove);

      rangeCard.appendChild(grid);
      rangeCard.appendChild(descField);
      factorEntry.rangesContainer.appendChild(rangeCard);
    }

    // ========== ACTIONS ==========
    // Removed btn-new, btn-import, file-input event listeners

    function loadTest(data) {
      // Clear existing
      state.questions = [];
      state.factors = [];
      qList.innerHTML = '';
      fList.innerHTML = '';

      // Store existing createdAt timestamp
      existingCreatedAt = data.createdAt || null;

      // Load basic info (temporarily enable ID field to set value)
      const idField = document.getElementById('test-id');
      idField.removeAttribute('readonly');
      idField.style.background = '';
      idField.style.cursor = '';
      
      idField.value = data.id || '';
      document.getElementById('test-title').value = data.title || '';
      document.getElementById('test-desc').value = data.description || '';
      document.getElementById('test-tag').value = data.tag || '';
      document.getElementById('test-category').value = data.category || 'para-voce';
      document.getElementById('article-url').value = data.articleUrl || '';
      document.getElementById('video-url').value = data.videoUrl || '';
      document.getElementById('featured').checked = data.featured || false;
      document.getElementById('curadoria').checked = data.curadoria || false;
      document.getElementById('test-visibility').value = data.visibility || 'public';
      document.getElementById('test-instr').value = data.instructions || '';
      document.getElementById('est-time').value = data.estimatedTime || '';
      
      // Restore readonly state after a brief delay
      setTimeout(() => {
        idField.setAttribute('readonly', 'readonly');
        idField.style.background = '#f8f9fa';
        idField.style.cursor = 'not-allowed';
      }, 100);

      // Reset counter
      questionIdCounter = 1;

      // Load questions
      (data.questions || []).forEach(q => {
        if (q.id >= questionIdCounter) questionIdCounter = q.id + 1;
        addQuestion(q);
      });

      // Load factors
      (data.scoring?.factors || []).forEach(f => addFactor(f));

      updateCounts();
    }

    // Load test from server (for edit mode)
    async function loadTestFromServer(testId) {
      try {
        const response = await fetch(`/api/tests/${testId}`);
        
        if (!response.ok) {
          throw new Error('Teste não encontrado');
        }
        
        const result = await response.json();
        
        if (!result.success || !result.test) {
          throw new Error('Erro ao carregar teste');
        }
        
        const testData = result.test;
        loadTest(testData);
        
        // Update save button text
        const saveBtn = document.getElementById('btn-save-server');
        if (saveBtn) saveBtn.textContent = '💾 Atualizar Teste';
      } catch (error) {
        alert(`Não foi possível carregar o teste: ${error.message}`);
      }
    }

    // Initialize edit mode on page load
    window.addEventListener('DOMContentLoaded', () => {
      if (editMode && editTestId) {
        loadTestFromServer(editTestId);
      }
    });

    // Removed btn-export event listener

    document.getElementById('btn-save-server').addEventListener('click', async () => {
      const data = collectData();
      
      if (!data.title) {
        alert('❌ Defina o título do teste antes de salvar');
        return;
      }
      
      if (!data.id) {
        alert('❌ Erro: ID do teste não foi gerado corretamente');
        return;
      }
      
      try {
        let response;
        
        if (editMode && editTestId) {
          // Edit mode: Use PUT directly
          response = await fetch(`/api/tests/${editTestId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
          });
        } else {
          // Create mode: Try POST first, fallback to PUT if exists
          response = await fetch('/api/tests', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
          });

          // If test exists, try PUT (update)
          if (!response.ok) {
            const error = await response.json();
            if (error.error && error.error.includes('exists')) {
              response = await fetch(`/api/tests/${data.id}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
              });
            }
          }
        }

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Erro ao salvar teste');
        }

        const result = await response.json();
        
        // Show success popup
        alert(editMode ? `✅ Teste "${data.title}" atualizado com sucesso!` : `✅ Teste "${data.title}" criado com sucesso!`);
        
        // Redirect to admin dashboard
        if (window.parent !== window) {
          // If in iframe, redirect parent window
          window.parent.postMessage({ type: 'testSaved', testId: data.id }, '*');
          window.parent.location.href = '/admin';
        } else {
          // If standalone, redirect this window
          window.location.href = '/admin';
        }
        
      } catch (error) {
        alert(`Erro ao salvar teste: ${error.message}`);
      }
    });

    // Removed btn-preview event listener

    const copyBtn = document.getElementById('btn-copy');
    copyBtn.addEventListener('click', async () => {
      const data = collectData();
      try {
        await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
        const prevText = copyBtn.textContent;
        copyBtn.textContent = '✅ Copiado';
        setTimeout(() => { copyBtn.textContent = prevText; }, 1200);
      } catch (err) {
        copyBtn.textContent = '❌ Falha';
        setTimeout(() => { copyBtn.textContent = '📋 Copiar JSON'; }, 1200);
      }
    });

    document.getElementById('btn-close-preview').addEventListener('click', () => {
      previewSection.style.display = 'none';
    });

    // Auto-generate ID from title
    document.getElementById('test-title').addEventListener('input', (e) => {
      const title = e.target.value.trim();
      const idField = document.getElementById('test-id');
      
      if (!editMode || !idField.value) {
        idField.value = generateUniqueId(title);
      }
    });
    
    document.getElementById('btn-add-question').addEventListener('click', () => addQuestion());
    document.getElementById('btn-add-factor').addEventListener('click', () => addFactor());

    // Clear factors link (after import)
    document.getElementById('clear-factors-link').addEventListener('click', (e) => {
      e.preventDefault();
      if (confirm('Tem certeza que deseja limpar todos os fatores gerados automaticamente?')) {
        state.factors = [];
        fList.innerHTML = '<div class=\"empty-state\"><div class=\"empty-state-icon\">📊</div><p>Nenhum fator adicionado.</p></div>';
        document.getElementById('import-info').style.display = 'none';
        updateCounts();
      }
    });

    // Import button
    document.getElementById('btn-import-questions').addEventListener('click', openImportModal);
    document.getElementById('btn-cancel-import').addEventListener('click', closeImportModal);
    
    // Import data textarea listener
    document.getElementById('import-data').addEventListener('input', previewImportData);
    
    // Close modal on overlay click
    document.getElementById('import-modal').addEventListener('click', (e) => {
      if (e.target.id === 'import-modal') {
        closeImportModal();
      }
    });

    // Exemplo rápido
    const sampleData = {
      id: 'oci_exemplo',
      title: 'Inventário Obsessivo-Compulsivo - OCI',
      description: 'Avalia sintomas obsessivo-compulsivos em diferentes dimensões',
      tag: 'Ansiedade',
      category: 'para-voce',
      videoUrl: '',
      articleUrl: '',
      featured: false,
      curadoria: false,
      testType: 'questionnaire',
      visibility: 'public',
      isPremium: false,
      instructions: 'Leia cada afirmação e indique o quanto ela se aplica a você.',
      estimatedTime: '5-10 minutos',
      questions: [
        { id: 1, title: 'Eu tenho acumulado tantas coisas que elas já estão me atrapalhando.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 2, title: 'Eu verifico coisas mais vezes do que é necessário.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 3, title: 'Eu fico chateado se os objetos não estão arrumados corretamente.', type: 'likert', weight: 1, reverse: true, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 4, title: 'Eu sinto vontade de contar enquanto estou fazendo coisas.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 5, title: 'Eu sinto dificuldade em tocar um objeto se sei que este já foi tocado por estranhos ou por certas pessoas.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 6, title: 'Eu tenho dificuldades em controlar meus próprios pensamentos.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 7, title: 'Eu coleciono coisas de que não preciso.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 8, title: 'Eu verifico repetidamente as portas, janelas, gavetas, etc.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 9, title: 'Eu fico chateado se outras pessoas mudam as coisas que arrumei.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 10, title: 'Eu sinto necessidade de repetir certos números.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 11, title: 'Às vezes tenho que me lavar simplesmente porque me sinto contaminado.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 12, title: 'Pensamentos desagradáveis que invadem minha mente contra a minha vontade me deixam chateado.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 13, title: 'Evito jogar coisas fora, pois tenho medo de precisar delas em outro momento.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 14, title: 'Eu verifico repetidamente o gás, as torneiras e os interruptores de luz após desligá-los.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 15, title: 'Eu necessito que as coisas estejam arrumadas em uma determinada ordem.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 16, title: 'Eu acredito que há números bons e ruins.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 17, title: 'Eu lavo as minhas mãos mais vezes que o necessário.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] },
        { id: 18, title: 'Eu tenho pensamentos impróprios com frequência e tenho dificuldade em me livrar deles.', type: 'likert', weight: 1, reverse: false, options: [{ value: 1, text: 'Discordo totalmente' }, { value: 2, text: 'Discordo parcialmente' }, { value: 3, text: 'Nem concordo nem discordo' }, { value: 4, text: 'Concordo parcialmente' }, { value: 5, text: 'Concordo totalmente' }] }
      ],
      scoring: {
        factors: [
          {
            id: 'fator-geral',
            name: 'Fator Geral',
            questionIds: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
            ranges: [
              { min: 18, max: 31, level: 'Baixo', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **baixo**.' },
              { min: 32, max: 45, level: 'Médio', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **médio**.' },
              { min: 46, max: 59, level: 'Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **alto**.' },
              { min: 60, max: 100, level: 'Muito Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **muito alto**.' }
            ]
          },
          {
            id: 'ansiedade-reativa',
            name: 'Ansiedade Reativa',
            questionIds: [1, 7, 8, 9, 10, 16, 17, 18],
            ranges: [
              { min: 8, max: 14, level: 'Baixo', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **baixo**.' },
              { min: 15, max: 21, level: 'Médio', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **médio**.' },
              { min: 22, max: 28, level: 'Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **alto**.' },
              { min: 29, max: 40, level: 'Muito Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **muito alto**.' }
            ]
          },
          {
            id: 'ansiedade-saudavel',
            name: 'Ansiedade Saudável',
            questionIds: [2, 3, 4, 5, 6],
            ranges: [
              { min: 5, max: 9, level: 'Baixo', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **baixo**.' },
              { min: 10, max: 14, level: 'Médio', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **médio**.' },
              { min: 15, max: 19, level: 'Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **alto**.' },
              { min: 20, max: 35, level: 'Muito Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **muito alto**.' }
            ]
          },
          {
            id: 'ansiedade-cumulativa',
            name: 'Ansiedade Cumulativa',
            questionIds: [11, 12, 13, 14, 15],
            ranges: [
              { min: 5, max: 9, level: 'Baixo', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **baixo**.' },
              { min: 10, max: 14, level: 'Médio', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **médio**.' },
              { min: 15, max: 19, level: 'Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **alto**.' },
              { min: 20, max: 25, level: 'Muito Alto', description: 'Este teste não apresenta tabelas de referência. Com base em quartis, seu resultado se mostra **muito alto**.' }
            ]
          }
        ]
      }
    };

    document.getElementById('btn-sample').addEventListener('click', () => {
      loadTest(sampleData);
    });

    document.getElementById('btn-clear').addEventListener('click', () => {
      if (!confirm('Limpar todos os campos?')) return;
      state.questions = [];
      state.factors = [];
      qList.innerHTML = '';
      fList.innerHTML = '';
      
      // Clear ID field (temporarily enable to clear)
      const idField = document.getElementById('test-id');
      idField.removeAttribute('readonly');
      idField.value = '';
      idField.setAttribute('readonly', 'readonly');
      
      document.getElementById('test-title').value = '';
      document.getElementById('test-desc').value = '';
      document.getElementById('test-tag').value = '';
      document.getElementById('video-url').value = '';
      document.getElementById('article-url').value = '';
      document.getElementById('featured').checked = false;
      document.getElementById('curadoria').checked = false;
      document.getElementById('test-visibility').value = 'public';
      document.getElementById('test-instr').value = '';
      document.getElementById('est-time').value = '';
      updateCounts();
    });

    // Preview Results
    document.getElementById('btn-preview-results').addEventListener('click', () => {
      // Collect current test data
      const testData = collectData();
      
      // Validate basic requirements
      if (!testData.id || !testData.title || testData.questions.length === 0) {
        alert('Por favor, preencha pelo menos ID, Título e adicione questões antes de pré-visualizar.');
        return;
      }
      
      // Get selected scenario
      const scenario = document.getElementById('preview-scenario').value;
      
      // Generate fake answers based on scenario
      const answers = generateFakeAnswers(testData, scenario);
      
      // Store in sessionStorage
      sessionStorage.setItem('previewTestData', JSON.stringify(testData));
      sessionStorage.setItem('previewAnswers', JSON.stringify(answers));
      
      // Open preview in new tab
      window.open('../test.html?preview=true', '_blank');
    });
    
    // Generate fake answers based on scenario
    function generateFakeAnswers(testData, scenario) {
      return testData.questions.map((q, idx) => {
        if (q.type === 'scale') {
          const min = q.min ?? 0;
          const max = q.max ?? 10;
          let value;
          
          // Account for reverse scoring
          const isReversed = q.reverse === true;
          let effectiveScenario = scenario;
          
          // Invert scenario for reversed questions
          if (isReversed && scenario === 'min') {
            effectiveScenario = 'max';
          } else if (isReversed && scenario === 'max') {
            effectiveScenario = 'min';
          }
          
          if (effectiveScenario === 'min') {
            value = min;
          } else if (effectiveScenario === 'max') {
            value = max;
          } else if (scenario === 'mid') {
            value = Math.floor((min + max) / 2);
          } else { // random
            value = Math.floor(Math.random() * (max - min + 1)) + min;
          }
          
          return { value, label: `Escala: ${value}` };
          
        } else if (q.type === 'text') {
          return { value: 0, label: 'Resposta de texto simulada' };
          
        } else { // single, likert, yesno - multiple choice with options
          const options = q.options || [];
          if (options.length === 0) {
            return { value: 0, label: 'Sem opção' };
          }
          
          let selectedOption;
          
          // Account for reverse scoring
          const isReversed = q.reverse === true;
          let effectiveScenario = scenario;
          
          // Invert scenario for reversed questions
          if (isReversed && scenario === 'min') {
            effectiveScenario = 'max';
          } else if (isReversed && scenario === 'max') {
            effectiveScenario = 'min';
          }
          
          if (effectiveScenario === 'min') {
            // Select option with minimum value
            selectedOption = options.reduce((min, opt) => 
              (Number(opt.value) < Number(min.value)) ? opt : min
            );
          } else if (effectiveScenario === 'max') {
            // Select option with maximum value
            selectedOption = options.reduce((max, opt) => 
              (Number(opt.value) > Number(max.value)) ? opt : max
            );
          } else if (scenario === 'mid') {
            // Select middle option
            const midIndex = Math.floor(options.length / 2);
            selectedOption = options[midIndex];
          } else { // random
            const randomIndex = Math.floor(Math.random() * options.length);
            selectedOption = options[randomIndex];
          }
          
          return { 
            value: Number(selectedOption.value) || 0, 
            label: selectedOption.text 
          };
        }
      });
    }

    // Initialize
    updateCounts();
    loadExistingTestIds();

    // Floating back-to-top
    document.addEventListener('DOMContentLoaded', () => {
      const btnTop = document.getElementById('btn-top');
      if (btnTop) {
        btnTop.addEventListener('click', () => {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }
    });
  </script>
<button id="btn-top" aria-label="Voltar ao topo" style="position:fixed;bottom:24px;right:24px;width:46px;height:46px;border:none;border-radius:50%;background:#1a4d2e;color:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.2);cursor:pointer;font-size:20px;z-index:500;">↑</button>

</html>

